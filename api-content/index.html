{"posts":[{"title":"GAMES101-17.材质与外观","content":"什么是各向同性，各向异性 ","link":"https://pigstar02.github.io/post/GAMES101-17.材质与外观/"},{"title":"GAMES101-16.光线追踪（蒙特卡洛积分与路径追踪）","content":"蒙特卡洛积分 不断的在定义域里随机采样，然后用它的函数值作为长方形的面积，最后求平均 如果我们用均匀分布的概率函数采样 则 用不同概率密度函数都可以 采样次数越大越准 路径追踪 Whitted-Style风格是错的 只有一次弹射 都认为是完全镜面反射 然后就需要上节课学的渲染方程 但是那个太难算了，我们用蒙特卡洛积分的方法来求一个近似值 假设只算一个着色点的 所以： Lo(p,ωo)=∫Ω+Li(p,ωi)fr(p,ωi,ωo)(n⋅ωi)dωi≈1N∑i=1NLi(p,ωi)fr(p,ωi,ωo)(n⋅ωi)p(ωi)\\begin{aligned} L_{o}(p,\\omega_{o})&amp; =\\int_{\\Omega^+}L_i(p,\\omega_i)f_r(p,\\omega_i,\\omega_o)(n\\cdot\\omega_i)\\text{d}\\omega_i \\\\ &amp;\\approx\\frac{1}{N}\\sum_{i=1}^N\\dfrac{L_i(p,\\omega_i)f_r(p,\\omega_i,\\omega_o)(n\\cdot\\omega_i)}{p(\\omega_i)} \\end{aligned} Lo​(p,ωo​)​=∫Ω+​Li​(p,ωi​)fr​(p,ωi​,ωo​)(n⋅ωi​)dωi​≈N1​i=1∑N​p(ωi​)Li​(p,ωi​)fr​(p,ωi​,ωo​)(n⋅ωi​)​​ 对于一个点p我们有以下算法求这个点接受到的总能量 但是上述还是没有解决多次反射的问题 上述光线没经过光源就跳过了，若没经过光源但是经过物体也应该处理 只需要递归处理q点 但是会有一些问题 递归下去将会指数爆炸 如果我们只发送一根光线就可以避免指数爆炸这种情况 这样用n = 1做蒙特卡洛积分就叫路径追踪 但是这样噪声非常大 所以这里简化一次采样的过程，改为多次采样 相机看向一个像素，可以对像素细分成多个采样点，每个采样点做一次路径追踪 这个递归是没有出口的 当我们递归求解q的时候，它又会递归求解p，就会无限递归 但是真实世界就是无限反射的 递归次数少了能量有损失，多了会死循环 所以我们引入一个类似俄罗斯轮盘的决策战略。有P的概率继续递归，（1-P）的概率结束递归，最后的能量是Lo/P 这样子的做法可以让期望是和原来相同的 P可以一开始设定，也可以动态生成 上述的代码就是正确的了，但是不同采样率效果不同 但是上面发射光线是均匀发射的 当光源较小时，有效光线（经过光源的光线）就很少，这就造成了极大地浪费 所以我们期望找到一种高效的发射方向的选择方式，即换一个概率函数 不过我们也可以换一个思路 原来是从p点发射光线，看光线能否击中光源或反光物体，但是并不知道光源在物体的哪个位置 我们可以直接对光源进行积分，看落在这个点上的光线有多少 蒙特卡洛允许任何方式的采样,只需要采样的东西和积分的东西一致就好 原来渲染方程积分域是单位空间角，现在要转变成光源上的发光面积，只需要找到他们的对应关系，换元即可 最后我们就可以把光线追踪分为两部分： 直接从光源来的光（要检查中间是否有遮挡，就是发射一个光线看打到的点是不是着色点） 从别的物体反射过来的光 ","link":"https://pigstar02.github.io/post/GAMES101-16.光线追踪（蒙特卡洛积分与路径追踪）/"},{"title":"GAMES101-15.光线追踪（辐射度量学、渲染方程与全局光照）","content":"辐射度量学 为了精确地定义光的属性（空间上的）的方法 图形学中的辐射度量学是研究和描述光在空间中传播和相互作用的科学。它涉及到能量、波长、频率、光线、光谱和颜色等概念，是图形学中渲染和光照计算的基础。 辐射度量学主要关注以下几个方面： 能量（Radiant Energy）：指光的能量，单位是焦耳（J） 辐射通量（Radiant Flux）：指光在单位时间内通过一个表面的能量，单位为瓦特（W）。 辐射照度（Radiant Flux Density）：指单位面积上的辐射通量，单位为瓦特/平方米（W/m²）。 光谱辐射度量学（Spectral Radiometry）：研究不同波长的光在空间中传播和相互作用的科学，涉及到光谱能量分布、光谱色度学、光谱成像等方面。 能量守恒（Energy Conservation）：辐射度量学中一个重要的原则是能量守恒，即能量不能被创建或毁灭，只能被转换成其他形式。 在图形学中，辐射度量学可以用于计算光照模型、材质属性、阴影、反射、折射等方面，对于创建真实感的渲染效果非常重要。 辐射强度Radiant Intensity 辐射（发光）强度是指每单元立体角点光源发射的光 立体角 二维平面中我们定义角度为弧长除以半径 这样子的好处是角度不会随着半径而变化 我们想要三维空间中也有这个性质 所以提出立体角的概念 定义为以球心为顶点的圆锥和球表面相交的面积除以半径的平方 如何定义呢？ 首先光线和z轴有一个角度θ\\thetaθ，然后和y轴有一个角度α\\alphaα 辐照度Irradiance 单位面积（必须和光线垂直，否则要求投影）接收的光照 之前的理解是能量均匀分布在球壳上 其实就是辐照度的概念，是和距离平方成反比的 但是辐射强度就不会变化，因为立体角不变，和球壳相交的面积会随着距离增加而增加 辐射Radiance 辐射是描述光在环境中的分布 每投影单位面积每单位立体角的功率。 L(p,ω)=d2Φ(p,ω)dωdAcos⁡θ\\begin{gathered} L(p,\\omega) = \\frac{\\text{d}^2\\Phi(\\text{p},\\omega) } {\\text{d}\\omega\\text{d}A\\cos\\theta } \\end{gathered} L(p,ω)=dωdAcosθd2Φ(p,ω)​​ 和Irradiance比有了方向 Irradiance就是各个方向的radiance积分 反射 过程理解成某一个小块接收到了能量，然后再把它发射到四面八方 BRDF 不同方向反射的能量分布是不同的 BRDF描述了反射能量是如何分布的 渲染方程 就是在上面的基础上考虑上自身发光的能量 而且上面只考虑了光源，也有可能经过别的物体反射的光照到了着色点，也要加上 Lo(p,ωo)=Le(p,ωo)+∫Ω+Li(p,ωi)fr(p,ωi,ωo)(n⋅ωi)dωiL_{o}(p,\\omega_{o})=L_{e}(p,\\omega_{o})+\\int_{\\Omega^{+}}L_{i}(p,\\omega_{i})f_{r}(p,\\omega_{i},\\omega_{o})(n\\cdot\\omega_{i})\\mathrm{d}\\omega_{i} Lo​(p,ωo​)=Le​(p,ωo​)+∫Ω+​Li​(p,ωi​)fr​(p,ωi​,ωo​)(n⋅ωi​)dωi​ 面光源可以看成点光源的集合 求解时把求和换成积分即可 全局光照 经过一系列数学变换，渲染方程可以写成算子的形式 展开 这样就可以看成多次反射的叠加 ![image-20230428173314700](/Users/zxy/Library/Application Support/typora-user-images/image-20230428173314700.png) 随着反射光线变多，变得越来越亮 但不是无限制的叠加，最后会收敛到一个值 上方的灯会突然变亮是因为在玻璃中会反射多次，所以增加一次可能还没有反射出来 只考虑自身发光就是光栅化的效果 ","link":"https://pigstar02.github.io/post/GAMES101-15.光线追踪（辐射度量学、渲染方程与全局光照）/"},{"title":"GAMES101-14.光线追踪（加速结构）","content":"加速结构 均匀格子 找到包围盒 均匀分成格子 把物体的表面经过的格子标记 模拟光线射入 对于穿过的格子进行处理 有物体表面 没物体表面，不处理 但是格子太疏太密都不太好 太疏极端点就是啥也不分1×11 \\times 11×1，那就是个所有物体求交 太密就会和很多（内部没有物体表面）的格子求交 在三维空间中，经验值是： 格子数量=27×物体数量\\text{格子数量} = 27 \\times \\text{物体数量} 格子数量=27×物体数量 网格结构在物体较多且分布均匀的画面中表现较好 空间划分 划分方法 八叉树,平面情况下,八叉树是个四叉树 停止条件：当这个格子已经空了，或者只有很少的物体就不细分下去了 这样子划分是2维度2^{维度}2维度叉树 KD-Tree 有几个维度就按这些维度交替划分，循环往复 比如说三维就是xyzxyz... 每次划分总是一分为二所以是二叉树 BSP-Tree是可以斜着砍，不像kdtree要横平竖直 但是维度越高越麻烦，二维要用线，三维就要用一个平面，更高维就要用超平面 KD-Tree 预处理 横竖不断交替划分，上图只是递归了一个，每个格子应该都要继续划分 最后是一个满二叉树的结构 实际的物体不存储在中间节点上，只存储于叶子结点 求交 类似于遍历上面这课二叉树，如果和当前节点有交，则遍历两个儿子，否则就终止 本质是找到一条从根节点到叶子节点的路径，复杂度就是树的高度，O(log2n)O(log_2n)O(log2​n) 找不到就是没有相交 问题 预处理时划分后要判断物体和格子的交点 一个物体可能和多个叶子结点有交，要判断多次 物体划分 Bounding Volume Hierarchy (BVH) BVH如何解决上述问题 按照物体划分成两个子节点而不是空间 这样子只需要求一堆物体构成集合的包围盒就好了，不需要求物体和空间的交 虽然两个兄弟节点的包围盒有交集（如上图蓝色和绿色），但是物体是属于其中一个，最后同一物体和光线求交也只会求一次 递归过程：不断划分物体集合，直到里面有较少的物体 划分方法： 划分方向： 我们总是想要划分的较均匀，可以每次划分较长的一边 划分位置： 每次划分在数量上尽可能均匀，每个物体（三角形）取它们的重心为关键字排序，然后以最中心的为轴划分，排序复杂度是O(nlogn)O(nlogn)O(nlogn) 我们只需要求中位数，可以使用nth_elenment，复杂度是O(n)O(n)O(n)的 求交 ","link":"https://pigstar02.github.io/post/GAMES101-14.光线追踪（加速结构）/"},{"title":"GAMES101-13.光线追踪（基本原理）","content":"光线追踪 光栅化无法做到的 全局的效果，比如软阴影 铜镜反射效果 间接光照（弹射不止一次） 光线追踪能带来真实的物理效果，但是渲染很慢，一般用于电影这种离线的渲染 光线 关于光线的定义： 光线是按直线传播的 光线之间交叉也不会发生碰撞 光线从光源传播到眼睛的整个过程是可逆的 步骤 从相机往画面的每个像素连一条线，叫eye-light 交于场景中的点（只考虑第一次相交，后面遮挡的不用管） 从交点连一条线到光源（如果中间没有遮挡，说明这点不是阴影，就可以用Blinn Phong等模型去着色） 但是上面还是只有一次反射 Recursive (Whitted-Style) Ray Tracing 从相机出发的第一条光线加primary ray 之后弹射的光线叫secondary ray 光线传播过程中弹射的点的着色最后会累加到最后的像素中，当然反射折射是会有衰减的 如何求交点 光线的数学定义： r(t)=o+td (0≤ t&lt;∞){\\textbf{r}(t)=\\textbf{o}+t\\textbf{d}~~~~~(0\\leq~t&lt;\\infty)} r(t)=o+td (0≤ t&lt;∞) 若求和一个球的相交，c是圆心坐标，半径是R，球面定义如下 p:(p−c)2−R2=0\\textbf{p}:(\\textbf{p}-\\textbf{c})^2-R^2=0 p:(p−c)2−R2=0 则只要联立上面两个方程就好了 (o+td−c)2−R2=0at2+bt+c=0,wherea=d⋅db=2(o−c)⋅dc=(o−c)⋅(o−c)−R2t=−b±b2−4ac2a\\begin{aligned} &amp;(\\textbf{o}+t\\textbf{d}-\\textbf{c})^2-R^2 =0 \\\\ &amp;at^2+bt+c=0,\\text{where} \\\\ &amp;a=\\textbf d\\cdot\\textbf d \\\\ &amp;b=2(\\textbf{o}-\\textbf{c})\\cdot\\textbf{d} \\\\ &amp;c=(\\textbf{o}-\\textbf{c})\\cdot(\\textbf{o}-\\textbf{c})-R^2 \\\\ &amp;t=\\dfrac{-b\\pm\\sqrt{b^2-4ac}}{2a} \\end{aligned} ​(o+td−c)2−R2=0at2+bt+c=0,wherea=d⋅db=2(o−c)⋅dc=(o−c)⋅(o−c)−R2t=2a−b±b2−4ac​​​ 注意t表示光线传播时间，要非负实数 这个方法可以推广到一般性的隐式表面，那么显式的呢？ 光线与三角形求交 首先忽略了光线和三角形平面平行的情况 分解成两步 光线和三角形所在平面求交 定义平面： 法线 平面内的某一个点 \\begin{array} \\textbf{p}:(\\textbf{p}-\\textbf{p}&#039;)\\cdot\\textbf{N}=0\\\\ \\text{化简得：}\\\\ ax+by+cz+d=0 \\end{array} 最后联立解得：(注意检查t的范围) Set p=r(t)and solve for t(p−p′)⋅N=(o+td−p′)⋅N=0t=(p′−o)⋅Nd⋅Ncheck:0≤t&lt;∞\\begin{gathered} \\text{Set }\\textbf{p}=\\textbf{r}(t)\\text{and }\\text{solve for }t \\\\ (\\textbf{p}-\\textbf{p}&#x27;)\\cdot\\textbf{N}=(\\textbf{o}+t\\textbf{d}-\\textbf{p}&#x27;)\\cdot\\textbf{N}=0 \\\\ t=\\dfrac{(\\textbf{p}&#x27;-\\textbf{o})\\cdot\\textbf{N}}{\\textbf{d}\\cdot\\textbf{N}}\\quad\\textbf{check:}0\\leq t&lt;\\infty \\end{gathered} Set p=r(t)and solve for t(p−p′)⋅N=(o+td−p′)⋅N=0t=d⋅N(p′−o)⋅N​check:0≤t&lt;∞​ 交点是否在三角形内部 根据之前学的重心坐标能把交点坐标用顶点表达出来，只要判断中心坐标三个系数非负并且和为1就好了 光线和物体求交 之前说过显式物体表达一般都是分成很多和三角形，只需要对每个三角形求交就好了 显然这样做效率很低，每次光线都要和场景里所有的三角形求交 那么如何加速呢？ 包围盒（Bounding Volumes） 能用一个简单形状把物体圈起来 如果包围盒都碰不到光线，物体更碰不到 长方体 我们把长方体的6个面看成3对相对的平面的交集 通常我们使用的都是Axis-Aligned Bounding Box (AABB)（轴对齐包围盒），就是平面和xy平面或xz平面或yz平面平行 光线和包围盒求交 先看二维情况 进入内部要求水平竖直都进入，所以时间上取max 离开内部只要从任意一边离开即可，所以时间上取min 三维情况类比二维 求出三组相对平面的进入时间和离开时间，则 但是光线是一个射线 如果texist&lt;0t_{exist} &lt; 0texist​&lt;0，盒子在光源后面 如果texist≥0&amp;&amp;tenter&lt;0t_{exist} \\geq 0 \\&amp;\\&amp; t_{enter}&lt;0texist​≥0&amp;&amp;tenter​&lt;0，光源在盒子内部 综上，ttenter&lt;texit&amp;&amp;texit≥0t_{tenter}&lt;{t}_{exit}\\&amp;\\&amp;t_{exit} \\geq0ttenter​&lt;texit​&amp;&amp;texit​≥0时，光线穿过包围盒 AABB的好处 与包围盒求交转化为了和平面求交 如果平面垂直于某个坐标轴，则可以使用那条轴的分量进行计算 ","link":"https://pigstar02.github.io/post/GAMES101-13.光线追踪（基本原理）/"},{"title":"GAMES101-12.几何（网格处理）、阴影图","content":"网格操作 网格细分 细节更丰富，更光滑 Loop 细分 中点相连分成更多三角形 区分新的顶点和老的顶点，分别进行不同调整让平面光滑 新的顶点 加权的值可以说是经验值，认为A，B离当前点近一点，C，D远一点 老的顶点 Catmull-Clark细分 定义 四边形的面叫quard face 非四边形的面归为一类，叫non-quard face 度数不为4的点叫奇异点 步骤 每个面的中心点和它所在面的所有边的中点相连 这样每个非四边形面的的中心会变成奇异点，因为它的度数变成原来平面的边数 并且一次细分后不存在非四边形面，增加的奇异点个数是原来非四边形面的数量 更新点 新点 面中心 f=v1+v2+v3+v44f=\\frac{v_1 + v_2 + v_3 + v_4}{4} f=4v1​+v2​+v3​+v4​​ 边中心 e=v1+v2+f1+f24e=\\frac{v_{1}+v_{2}+f_{1}+f_{2}}{4} e=4v1​+v2​+f1​+f2​​ 老点 ν=f1+f2+f3+f4+2(m1+m2+m3+m4)+4p16m边的中点p当前点原来的坐标\\begin{gathered} \\nu=\\dfrac{f_1+f_2+f_3+f_4+2(m_1+m_2+m_3+m_4)+4p}{16} \\\\ m 边的中点\\\\ p 当前点原来的坐标 \\end{gathered} ν=16f1​+f2​+f3​+f4​+2(m1​+m2​+m3​+m4​)+4p​m边的中点p当前点原来的坐标​ loop细分只适用三角形面，catmull-clark更通用 网格简化 减少存储，但是要保证原有结构不会发生变化 有些图形放远了看（缩小）并不能看到细节，较多较少三角形效果差不多 所以不如用较少的三角形换取更好的性能 边坍缩 选择一条边，把它的两个端点合并成一个点，这个点可能不再是原来两个点之一 但是不是任意两个点都能合并的 错误合并可能会改变整体结构，所以要用到二次误差度量 二次误差度量（Quadric Error Metrics）： 找到一个点，使其到原本各平面距离的平方的和最小 对于每条边我们都用二次度量误差对其打分 每次选用二次度量误差最小的进行坍缩 ​ 但是坍缩后会影响到相连的边，他们的二次度量误差会发生改变，我们要对其进行更新 有两个操作，取最小和更新；可以用优先队列 这是一个贪心的过程，且是通过一步步局部贪心来逼近全局最优 struct node { int id; int score; bool operator&lt;(const node&amp; other) const { return score &lt; other.score; } } priority_queue&lt;node&gt; q; int idx = 0; for (edge e : Edges) { int S = get_score(e); q.push({idx++,S}); } while (q.size()) { auto [id,score] = q.top(); q.pop(); if (update[id]) {//待更新 score = get_score(Edges[id]); q.push({id,score}); update[id] = 0; } else { //坍缩操作 for (edge e : link_edge[id]) {//标记周围的边要更新 update[e.id] = 1; } } } 每条边只会出队入队它的两端点度数和次 网格正则化 让每个三角形尽可能均匀（正三角形） 但又不丢失表示细节 阴影图 这是之前没说的部分 Shadow Mapping 核心思想 我们能看到的点一定是光照的到并且相机也看得到的 在阴影中的点是光照不到但是相机能看到 步骤 假设相机在光源的位置，从光源看场景，记录一个深度图 从实际相机出发看场景，把当前能看到的点投影回第一步的图像中，如果对应的深度不一致，则该点被遮挡，应该为阴影 Shadow Mapping只能渲染硬阴影 硬阴影 软阴影 产生原因：光源有一定的大小 ","link":"https://pigstar02.github.io/post/GAMES101-12.几何（网格处理）、阴影图/"},{"title":"GAMES101-11.几何（曲线与曲面）","content":"曲线 应用 相机运动的轨迹，视角跟随变化 物体运动 矢量字体的绘制 贝塞尔曲线 开始和结束都要经过控制点，且切线是p0p1和p2p3 绘制 以下是三个点的情况： 对于一个变量t属于[0,1] 不断找每条线段的t:(1−t)t:(1-t)t:(1−t)的点 重复第二步，直到最后只剩一个点 对于每个t有一个点，把所有t最后剩下的点连起来就是赛贝尔曲线 代数形式 自底向上不断求线性插值 b01(t)=(1−t)b0+tb1b11(t)=(1−t)b1+tb2b02(t)=(1−t)b01+tb11=(1−t)2b0+2t(1−t)b1+t2b2\\begin{aligned} \\mathbf{b}_{0}^{1}(t) &amp;=(1-t)\\mathbf{b}_0 + t\\mathbf{b}_1 \\\\ \\textbf{b}_1^1(t) &amp;=(1-t)\\mathbf{b}_1+t\\mathbf{b}_2 \\\\ \\textbf{b}_0^2(t) &amp;=(1-t)\\mathbf{b}^1_0 + t\\mathbf{b}^1_1 \\\\ &amp;=(1-t)^2\\mathbf{b}_0+2t(1-t)\\mathbf{b}_1+t^2\\mathbf{b}_2 \\end{aligned} b01​(t)b11​(t)b02​(t)​=(1−t)b0​+tb1​=(1−t)b1​+tb2​=(1−t)b01​+tb11​=(1−t)2b0​+2t(1−t)b1​+t2b2​​ 展开其实可以发现就是一个二项式展开 结论： 这个结论同样适合三维空间的点 特点 贝塞尔曲线的仿射变换可以先把控制点仿射变换后再求贝塞尔曲线 ​ 注意：是仿射变换，投影不可以 贝塞尔曲线一定在控制点形成的凸包内 ​ 应用：如果控制点在一条线上，那么他们的凸包也 是一条线，相应的，贝塞尔曲线就是这条线 分段的贝塞尔曲线 当点较多时，只用一条贝塞尔曲线较困难 所以就用到了分段贝塞尔曲线 通常用四个控制点对应一条贝塞尔曲线 连续 C0连续 几何上挨在一起，同一个点 C1连续 前一曲线的后两个点和后一曲线的前两个点组成的线段共线，并且方向相反，长度相等 样条 通过给定集合构造的连续曲线，并且具有一定的连续导数，换句话说就是固定几个点的连续曲线 B样条 B是basic，是基函数 是贝塞尔曲线的扩展 贝塞尔曲线更改一个点，整个都会更改 B样条有局部性，改变一个点，只会影响周围一定范围的曲线 曲面 贝塞尔曲面 取4×44 \\times 44×4个点，对每4个x相同的点求贝塞尔曲线 这样就有四条曲线了 固定y，在四条曲线上取y相同的四个点再求贝塞尔曲线 扫描一遍就可以得到曲面了 ","link":"https://pigstar02.github.io/post/GAMES101-11.几何（曲线与曲面）/"},{"title":"GAMES101-10.几何（基本表示方法）","content":"隐式表达 表示一定的关系，并不给你实际的点 单位球：x2+y2+z2=1x^2+y^2+z^2=1x2+y2+z2=1 一般的：f(x,y,z)=0f(x,y,z) = 0f(x,y,z)=0 好处容易判断一个点在不在面上，存储方便（一个公式） 坏处是无法通过方程直观感受几何的形状 显式表达 直接给出点坐标 通过参数映射的方式给出 跑一遍uv图就可以得到右边的三维图像 CSG（隐式） 通过不同的基本模型组合出复杂模型 距离函数（隐式） 分别有A、B两张图的距离函数 把它们融合得到新的距离函数 把它还原回去就得到了新的平面 把等于0的点找出来连起来就是一个新的平面 距离函数可能不太好写，可以使用水平集 就是用一个方格来描述距离函数 分形（隐式） 显著的特点就是局部和整体很相似 类似于递归 容易走样，因为递归是指数复杂度的，变化频率很高 点云（显式） 点云就是一堆点的集合 密度过低就构成不了一个面 多边形网格（显式） 最常用的 文本存点（.obj） v：点 vt：纹理坐标 vn：法线 f：三角形（由那几个点构成）（每个点是 点/纹理坐标/法线坐标） ","link":"https://pigstar02.github.io/post/GAMES101-10.几何（基本表示方法）/"},{"title":"GAMES101-9.着色（插值、高级纹理映射）","content":"插值 为什么 我们已知三角形三个顶点的属性，想要知道三角形内部点的属性，并且他们是平滑过渡的 重心坐标 三角形所在平面内任何一个点都能被三个顶点线性表示 (x,y)=αA+βB+γCα+β+γ=1因为在三角形内部还需满足α,β,γ≥0\\begin{aligned} (x,y) = &amp;\\alpha A + \\beta B + \\gamma C \\\\ &amp;\\alpha + \\beta + \\gamma = 1\\\\ \\text{因为在三}&amp;\\text{角形内部还需满足}\\\\ &amp;\\alpha , \\beta , \\gamma \\geq 0 \\end{aligned} (x,y)=因为在三​αA+βB+γCα+β+γ=1角形内部还需满足α,β,γ≥0​ 如图所示可以根据面积求得α,β,γ\\alpha , \\beta , \\gammaα,β,γ 化简： α=−(x−xB)(yC−yB)+(y−yB)(xC−xB)−(xA−xB)(yC−yB)+(yA−yB)(xC−xB)β=−(x−xC)(yA−yC)+(y−yC)(xA−xC)−(xB−xC)(yA−yC)+(yB−yC)(xA−xC)γ=1−α−β\\begin{aligned} &amp;\\alpha=\\dfrac{-(x-x_B)(y_C-y_B)+(y-y_B)(x_C-x_B)}{-(x_A-x_B)(y_C-y_B)+(y_A-y_B)(x_C-x_B)} \\\\ &amp;\\beta=\\dfrac{-(x-x_C)(y_A-y_C)+(y-y_C)(x_A-x_C)}{-(x_B-x_C)(y_A-y_C)+(y_B-y_C)(x_A-x_C)} \\\\ &amp;\\gamma=1-\\alpha-\\beta \\end{aligned} ​α=−(xA​−xB​)(yC​−yB​)+(yA​−yB​)(xC​−xB​)−(x−xB​)(yC​−yB​)+(y−yB​)(xC​−xB​)​β=−(xB​−xC​)(yA​−yC​)+(yB​−yC​)(xA​−xC​)−(x−xC​)(yA​−yC​)+(y−yC​)(xA​−xC​)​γ=1−α−β​ 相应的重心的坐标就是(13,13,13)(\\frac{1}{3}, \\frac{1}{3}, \\frac{1}{3})(31​,31​,31​) 纹理贴图 知道定点对应的纹理，只需把上述插值的坐标换成纹理的属性即可插值出内部的纹理 在之前学到的模型中就是把对应像素的kdk_dkd​替换，最后还是拥有原有的明暗高光 这只是二维平面，在三维空间中，投影后中心坐标会发生改变，所以不可用 纹理的放大 当我要把一个低分辨率的纹理贴到一个高分辨率的屏幕上时就会出现纹理的放大现象 本质是差值出来的uv，也就是对应纹理图的坐标不是一个整数，这个时候我们就会对它进行round，结果是周围邻近的几个点可能对应相同的uv 结果是会出现一块一块（走样现象） 双线性差值 对于非整数坐标找到离他最近的四个整数坐标点 接下来做三遍差值（叫双线性指水平和竖直） u00,u10u_{00},u_{10}u00​,u10​插值出u0u_0u0​ u01,u11u_{01},u_{11}u01​,u11​插值出u1u_1u1​ 最后竖直方向u0,u1u_0,u_1u0​,u1​插值出目标点 先竖直再水平是一样的 效果 Bicubic 取周围的16个 更加的精细，但是运算量更大 纹理过大 纹理的分辨率大于屏幕分辨率 一个像素内会包含很大一块纹理，就会出现锯齿、走样 可以采用超采样，相当于理论上提升屏幕的分辨率，但伴随着更大的计算花销 出现走样是因为采样频率跟不上像素内的高频信息 提高采样频率会带来更大花销，那如果不采样呢？ 如何求得范围内的平均值？也可能是极值 Mipmap（图像金字塔） 特点 快 近似查询，不是完全准确 查询范围是方形 用一张原始图生成多张图 每张图的大小都是前一张图的14\\frac{1}{4}41​ 总的存储是原来的1+14+116+...=431 + \\frac{1}{4} + \\frac{1}{16} + ... = \\frac{4}{3}1+41​+161​+...=34​，一个等比数列求和 取最大的L作为近似正方形的边长，查询的点是中心 查询 在原始图上是L×LL \\times LL×L在第log2Llog_2Llog2​L层会对应一个像素 但是L不是刚好是2的幂次，那就要用到插值 三线性插值 D=log2LD = log_2LD=log2​L 在两张图中分别做双线性差值，得到两个平滑的值 再在层与层之间做一遍插值，这样层级之间也能平滑过渡 缺点 远处（单个像素包含更大纹理图区域）会过分模糊，细节全都消失 各向异性过滤（Anisotropic Filtering） 这可以看成一个二维矩阵，每个图片都是左边的图片宽减少一半，上面的图片高减少一半 mipmap就是对应了主对角线上的图片 空间开销是原来的4倍 优点 原来的像素对应到纹理图上不一定是规则的方形，可能是一个长条的形状，如果用方形去指代就会出现过度模糊的后果，所以需要用到更合理的区域去替代 而Anisotropic Filtering预处理了这种情况 可以对长宽类似mipmap分别求层级，就能在二维图像数组找到对应的矩形区域 在处理矩形情况会好很多 但是如图矩形是斜着的，这种方法效果也不好 EWA 不规则的图形用多个圆形去覆盖它 缺点 多次查询时间复杂度高 优点 更准确的框图形 纹理的应用 环境光照/贴图 Spherical Map 可以记录在一个球面上然后在向世界地图一样展开 但是会造成极点位置的扭曲 Cube Map 把球上的光照信息记录在正方体的六个表面 凹凸贴图/法线贴图 纹理不仅可以定义颜色，也能定义法线的相对位移 这样就可以改变一个点的法线 黑色是原来的光滑平面 黄色是法线贴图 使p点的法线变成n点的到法线 计算 设原来是水平平面，法线是(0,1)(0,1)(0,1) 先求切线 dp=c×[h(p+1)−h(p)]dp = c \\times [h(p + 1) - h(p)]dp=c×[h(p+1)−h(p)] 切线是(1,dp)(1,dp)(1,dp) 法线就是把切线逆时针旋转90度 n(p)=(−dp,1)n(p) = (-dp,1)n(p)=(−dp,1) 位移贴图 区别 凹凸贴图是虚拟的位移 在边缘和影子灰露馅 位移贴图真实的修改了点的坐标 要求 模型足够细致，要不然就会跟不上纹理的频率 三维噪声 记录数据 在着色的过程中可以处理一些信息，记录在纹理中 最后只需要把着色和纹理的结果合成就好了 ","link":"https://pigstar02.github.io/post/GAMES101-9.着色（插值、高级纹理映射）/"},{"title":"GAMES101-8.着色（着色频率、图形管线、纹理映射）","content":"高光区域 当反射的光线直直指向相机，那就会看到这个点是高光的。 当时镜面反射时，入射光线和反射光线是关于法线对称的 较光滑区域的反射光分布在镜面反射光周围 半程向量 法线是入射光线l和反射光线r形成夹角的角平分线 v是视线，即相机和观测点的连线 入射光线l和视线v形成夹角的角平分线就叫半程向量 假设：v和r越接近等价于n和h越接近 直接用视线和反射光线也行 半程向量的优点是好算h=v+l∣∣v+l∣∣h = \\frac{v+l}{||v+l||}h=∣∣v+l∣∣v+l​ 这里不考虑角度偏移能量的损耗，只关注方向对了没（能否看到高光） 观测到公式中有一个指数p 观测上图可以很容易发现，随着指数增加，斜率减小（因为是负的），图像更陡。 这样一旦角度有细微的变化，y轴会有较明显的变化，对变化更加敏感，区分能力增强 反映在画面中就是随着p的增加高光越来越小 环境光 和观测角度无关 和反射角度无关 相当于一个常量，把每个点都提升一个亮度 这只是一个大胆的简化 着色频率 每个面着色一次 每个定点着色一次 每个顶点着色 那如何求顶点的法向量？ 每个顶点都会被周围多个三角形所用，那么我们就用周围相关的三角形平面的法向量求个平均作为顶点的法向量 但是每个三角形的影响不同，可以根据三角形的面积做一个加权平均 平面内部的点用差值来着色 每个像素着色一次 比较 当面不断细分，按面着色效果很贴近后两者了，极端的想一个面的大小是一个像素，那就相当于按像素着色 实时渲染管线 这里的线说的是一个过程，相当于图形渲染的流水线 纹理映射 定义不同的点有一个不同的属性 有一张关于描述纹理的图，模型中每一个点都对应纹理图里的一个坐标 不管这张图的大小，uv坐标轴总是[0,1][0,1][0,1] 左边是效果图，右边是每个点对应纹理图中坐标的示意图 可以看到一张图可以重复同一张纹理图，像是贴瓷砖一样 右图中能看到明显的分界线，但左图却没有，这取决于纹理的设计 ","link":"https://pigstar02.github.io/post/GAMES101-8.着色（着色频率、图形管线、纹理映射）/"},{"title":"GAMES101-7.着色（光照与基本着色模型）","content":"可见性 画家算法 近的物体会遮挡住远处的物体，只要从远到近依次画出物体，近物覆盖远物，就可以画出正确的画面 由远到近需要用到排序，复杂度是O(nlogn)O(nlogn)O(nlogn) 但是会出现一个环形互相叠的环就无法区分哪个最远 所以显然想要用画家算法需要找到一个拓扑序 想想挑竹签的游戏 Z-Buffer(深度缓存) 记录每一个像素最画面中最前（靠近相机）的距离 需要记录两个信息 深度缓存：记录深度，颜色深代表距离近 frame缓存：记录颜色，如果当前像素最浅深度被更新，则用当前物体的颜色更新当前像素颜色 //zbuffer初始化为无限大，因为下面我们取min，无限大相当于一个无用操作 for (each triangle T）//遍历每个三角形 for (each sample (x,y,z) in T) //遍历每个像素 if (z &lt; zbuffer[x,y]) //按照深度更新 framebuffer[x,y] = rgb; //深度更新了，更新对应颜色 zbuffer[x,y] = z; else 只需要遍历每个三角形和每个三角形包含的像素，如果像素个数是个常数，复杂度是O(n)O(n)O(n) Q:如何处理透明物体？ A:自己想的，先说结论，透明像素直接continue。首先透明物体会表现后一个较远距离的颜色，颜色肯定不更新，那距离也不应该更新，试想一下有三个物体远(红)中(黄)近(透明)，先遍历远的像素成红色，再遍历近的透明像素，如果更新了距离，接下来遍历中距离的黄色物体就无法更新颜色了（实际是远红借用了近透明的距离） 着色 用不同的材质处理物体不同的面 Blinn-Phong 反射模型 对于每个着色点，我们都认为它是平的。就算是曲面无限微分近似成平面。 局部性 着色的过程中，我们只关注要被着色的物体，不考虑其他物体对他的影响 比如下图物体背面的地面应该有影子是黑色，但是给地面着色的时候我们视物体不存在 漫反射 打到这个点的光从不同的角度均匀的反射出去 但是不同的角度和反射光线强度的关系是什么样的？ 首先认为光源的平行光是均匀的，那么如图接收到的光就和接收到的长度成正比。 倾斜后的有效长度就是红线部分，是入射光强度×cos⁡θ\\times \\cos\\theta×cosθ，θ\\thetaθ是入射光线和法线的夹角 光源 点光源每一时刻发出的光能量相同，都集中在一个球壳上(图是二维的，其实是三维中的一个球的表面) 球表面面积公式是S=4πr2S = 4 \\pi r^2S=4πr2，所以和r2r^2r2成反比 总结 吸收要和0取max，当余弦是负数是从下面照过来，不考虑折射没有实际物理含义 kdk_dkd​是一个系数，不同的材质、颜色对光的反射效果是不一样的 ","link":"https://pigstar02.github.io/post/GAMES101-7.着色（光照与基本着色模型）/"},{"title":"GAMES101-6.光栅化（深度测试与抗锯齿）","content":"Antifact 任何光栅化后和原图不符的现象，中文叫瑕疵 比如： 锯齿 摩尔纹 车轮效应 本质原因：信号变化的速度太快了，采样速度跟不上 反走样 频率 描述变化的速度 傅里叶级数 任何一个周期函数都可以写成一系列正弦余弦函数的线性组合以及一个常数项 如下图所示，相同的采样频率去采样不同频率的周期函数 当频率增加的时候，采样频率跟不上就会丢失很多信息，即把采样的点连起来不能恢复原来的函数 虚线的函数和实线的函数的采样结果是一样的，但他们的频率截然不同 滤波 滤波：就是去掉一些频域的内容 高通滤波：只让高频信息通过 从图中可以看到，高频对应了图中人物（内容）的轮廓信息 低通滤波：只让低频信息通过，阻碍高频信息，即使轮廓不明显，达到了模糊的效果 卷积 这是图形学上的简化操作 从结果上来看，是对每个点和其周围几个点进行平均操作，从而达到模糊的效果 空间域（时域）上的卷积等于频域上的乘 上述是用3×33 \\times 33×3的低通滤波，如果我们使用更大的矩阵呢，它的频域图将会变小 怎么理解呢？ 当矩阵很大时，大到比原来的图像还大，那滤波后图的每个像素都是一样的了，那高频信息就没了，表示在频域图中就是白色区域变小（越靠近中心表示频率越低） 模糊反走样 原理：下图是走样现象在频域上的反应，采样频率越小就是采样越稀疏，搬移的越密集，原始信号就会和复制粘贴的信号产生重叠，就是走样 先进行滤波模糊处理，再对滤波后的图像采样，点亮的像素的颜色和滤波后对应像素一致。 对应到频域图上的操作就是将高频信息砍掉，也就是发生重叠的部分 强调：一定要先滤波再采样，先采样再滤波是不行的 MSAA（Multisample Anti-Aliasing） 我们通过覆盖率来定义这个像素的颜色亮度 那么怎么计算覆盖率？ 把一个像素在理论上细分，分的越细致，最后结果越准确，类似于微分的思想，然后统计分完后覆盖的中心 坏处：显然不能越细分越好，计算每个点是否在三角形内需要耗费时间 FXAA（Fast Approximate AA） 是一种快速的近似抗锯齿技术，旨在提高图形质量并减少锯齿。与传统的MSAA（Multisample Anti-Aliasing）相比，FXAA可以更快地处理较大的场景，并且不需要额外的硬件支持。 FXAA通过对像素颜色进行平滑处理来减少锯齿和其他视觉噪点。它使用了一些启发式算法来检测锯齿和其他图像问题，并对其进行消除。这些算法包括检测高频率变化、过滤器阈值和局部对比度等。 FXAA虽然处理速度很快，但它也有一些缺点。由于它是一种近似技术，因此可能会导致某些细节丢失或模糊。此外，在某些情况下，它可能会产生类似于“水彩画”效果的图像问题。 总体而言，FXAA是一种适用于许多游戏引擎的快速抗锯齿技术。 TAA（Temporal AA） AA使用了前一帧和当前帧之间的信息来计算出运动物体的轨迹，然后对其进行平滑处理，从而消除锯齿和图像噪点。 TAA的原理是在连续两帧之间比较像素颜色值的变化，并根据这些变化来计算出物体在两帧之间的位置和运动方向。然后，通过对这些像素进行平均处理来模拟物体在两帧之间运动时产生的模糊效果。 TAA可以有效地降低图形中出现的锯齿、马赛克和其他视觉噪点，并提高图形质量。 ","link":"https://pigstar02.github.io/post/GAMES101-6.光栅化（深度测试与抗锯齿）/"},{"title":"GAMES101-5.光栅化（三角形的离散化）","content":"视锥 如何定义一个视锥 纵横比 = 宽度 / 高度 红色虚线构成的角叫做垂直可视角度，同样的也会有水平可视角度 从x轴方向看能观测到如上的图 这里假设了视锥底面的中心在(0,0,z)(0, 0, z)(0,0,z)的位置，则 tan⁡fovY2=t∣n∣aspect=rtt在这里是高度的一半\\begin{gathered} \\tan{\\frac{f o v Y}{2}}={\\frac{t}{|n|}} \\\\ aspect = \\frac{r}{t}\\\\ t在这里是高度的一半 \\end{gathered} tan2fovY​=∣n∣t​aspect=tr​t在这里是高度的一半​ MVP Model transformation (模型变换，放置物体) View transformation（视角变换，放置照相机） Projection transformation（投影变换，把物体映射到[−1,1]3[-1,1]^3[−1,1]3的立方体中） 前面我们已经学完了以上所有转化，最后所有图形都到了[−1,1]3[-1,1]^3[−1,1]3的立方体中，接下来我们要把它们在屏幕上展示出来 屏幕 屏幕可以看作一个二维数组，它的大小叫做分辨率，每个点叫做像素 像素 看成一个方块，它是关于rgb的一个三元组，每个颜色有256个等级 屏幕的空间 可以用一个整数下标来定义一个像素的位置 图中蓝色的下标就是(2,3) 光栅化 光栅化就是把图形画在屏幕上 我们先忽略z的影响，把x,y的平面画出 把图像伸缩到width×heightwidth \\times heightwidth×height 移到屏幕的中心(width2,height2\\frac{width}{2},\\frac{height}{2}2width​,2height​) 得到视口变换的矩阵 Mviewport=(widthh200with20height20heightt200100001)M_{viewport}=\\begin{pmatrix}\\frac{widthh}{2}&amp;0&amp;0&amp;\\frac{with}{2}\\\\ 0&amp;\\frac{height}{2}&amp;0&amp;\\frac{heightt}{2}\\\\ 0&amp;0&amp;1&amp;0\\\\ 0&amp;0&amp;0&amp;1\\end{pmatrix} Mviewport​=⎝⎜⎜⎛​2widthh​000​02height​00​0010​2with​2heightt​01​⎠⎟⎟⎞​ 三角形 为什么用三角形 三角形是最基本的多边形 任何多边形都可以拆分成若干个三角形 三角形的内部一定是同一平面的 内部外部定义清晰 方便构造渐变效果 采样 如果我们要显示一个图形，但是一个像素一部分在图形内，一部分在图形外，我们知道像素是一个最小放光单元，不能再细分，那么这个像素应不应该被点亮？ 那么我们只需要采样像素的中心点是否在图形内，用它来代表整个像素 bool inside(triangle t, int x, int y) { //判断点(x,y)和多边形t的关系 } for (int i = 0; i &lt; mx; i ++) { for (int j = 0; j &lt; mx; j ++) { image[i][j] = inside(t, i + 0.5, j + 0.5); } } 判断点在多边形内部与否 按照一个顺序计算P0P1×P0QP_0P_1 \\times P_0QP0​P1​×P0​Q，P1P2×P1QP_1P_2 \\times P_1QP1​P2​×P1​Q，P2P0×P2QP_2P_0 \\times P_2QP2​P0​×P2​Q，如果三个结果的正负性相同，则点在三角形内部，否则在三角形外部。 point P[3];//三角形三点坐标 for (int i = 0; i &lt; 3; i ++) { cross(p[i],Q,p[i],p[(i+1)%3])//计算叉积 } 如果一个点在边界上，由自己定义是否在三角形内 包围盒（bounding box） 作用：不需要遍历整个屏幕，只需要遍历刚好框住图形的一个矩形 定义：矩形的边界恰好是所有点分别在x，y上的极值 但是如果三角形是非常狭长的，角度又正好是45度，类似于一个对角线的摆放，那么上述方法还是会遍历很多无效的像素 所以我们可以遍历每一行，找每一行的最左和最右 锯齿 光栅化后，我们点亮相应的像素但是得到的并不是我们想要的三角形 得到的图形边缘是每个像素的轮廓，并不是光滑的，这就是锯齿 ","link":"https://pigstar02.github.io/post/GAMES101-5.光栅化（三角形的离散化）/"},{"title":"GAMES101-4.变换（模型、视图、投影）","content":"观测变换 视图变换 为什么要视角变换？ 以游戏为例，我们构建了一个三维场景，但是展示出来的是二维平面，从不同角度观察得到的画面是不同的，尽管场景里的模型没有发生任何变化 要想获得不同视角的画面就需要视角变换 一个位置两个方向 位置e 拍摄方向g 向上方向t（拍竖屏还是横屏） 步骤 关键：当观察者和被观察物体同时移动保持相对静止的时候，观测画面是不会变化的 所以我们固定观测者在原点，拍摄方向是-Z，向上方向是Y 最后只需要移动物体即可 先把位置平移到原点 Tview=[100−xe010−ye001−ze0001]T_{view} = \\left[{\\begin{array}{r r r r}{1}&amp;{0}&amp;{0}&amp;{-x_{e}}\\\\ {0}&amp;{1}&amp;{0}&amp;{-y_{e}}\\\\ {0}&amp;{0}&amp;{1}&amp;{-z_{e}}\\\\ {0}&amp;{0}&amp;{0}&amp;{1}\\end{array}}\\right] Tview​=⎣⎢⎢⎡​1000​0100​0010​−xe​−ye​−ze​1​⎦⎥⎥⎤​ 把观察方向旋转到-Z，向上方向旋转到Y，(g×tg \\times tg×t旋转到X) 由于正向旋转不太好求，我们可以求逆变换的矩阵，再对它求逆 旋转矩阵是正交矩阵，它的逆矩阵就是转置矩阵 Rview−1=[xg^×t^xtx−g0yg^×t^yty−g0zg^×t^ztz−g00001]R_{view}^{-1}=\\left[\\begin{array}{c c c c} x_{\\hat{g}\\times\\hat{t}}&amp;{x_{t}}&amp;{x_{-g}}&amp;{0}\\\\ {y_{\\hat{g}\\times\\hat{t}}}&amp;{y_{t}}&amp;{y_{-g}}&amp;{0}\\\\ {z_{\\hat{g}\\times\\hat{t}}}&amp;{z_{t}}&amp;{z_{-g}}&amp;{0}\\\\ {0}&amp;{0}&amp;{0}&amp;{1} \\end{array}\\right] Rview−1​=⎣⎢⎢⎡​xg^​×t^​yg^​×t^​zg^​×t^​0​xt​yt​zt​0​x−g​y−g​z−g​0​0001​⎦⎥⎥⎤​ Rview=[xg^×t^yg^×t^zg^×t^0xtytzt0x−gy−gz−g00001]R_{v i e w}=\\left[\\begin{array}{c c c c}{{x_{\\hat{g}\\times\\hat{t}}}}&amp;{{y_{\\hat{g}\\times\\hat{t}}}}&amp;{{z_{\\hat{g}\\times\\hat{t}}}}&amp;{{0}}\\\\ {{x_{t}}}&amp;{{y_{t}}}&amp;{{z_{t}}}&amp;{{0}}\\\\ {{x_{-g}}}&amp;{{y_{-g}}}&amp;{{z_{-g}}}&amp;{{0}}\\\\ 0&amp;{{0}}&amp;{{0}}&amp;{{1}}\\end{array}\\right] Rview​=⎣⎢⎢⎡​xg^​×t^​xt​x−g​0​yg^​×t^​yt​y−g​0​zg^​×t^​zt​z−g​0​0001​⎦⎥⎥⎤​ Mview=RviewTviewM_{view} = R_{view}T_{view} Mview​=Rview​Tview​ 投影变换 类似点光源和平行光的区别 正交投影 原来平行的线在投影中还是平行的，不会有近大远小的现象，更多用在工程制图中。 原理就是三视图，丢掉一个维度，每个点最后的投影只和x，y有关 这就产生了一个问题，(x,y,z1)和(x,y,z2)(x,y,z_1)和(x,y,z_2)(x,y,z1​)和(x,y,z2​)在投影中落在了同一点，那么就要区分看到的是哪一个点了 相同z的点将会形成一条轮廓 上述把z扔掉的做法对人理解上很直观，但是对于计算机来说不好操作 定义：[−1,1]3{[-1,1]^{3}}[−1,1]3叫做标准正方体，任何长方体包括正方体都可以映射成一个标准正方体 步骤 移动：把原来的物体的中心平移到原点 伸缩变换：把[l,r]×[b,t]×[f,n][l,r] \\times [b, t] \\times [f, n][l,r]×[b,t]×[f,n]在三个维度上分别映射到[−1,1]3{[-1,1]^3}[−1,1]3 namo接下来我们要把它写成矩阵的形式 Mortho=[2r−l00002t−b00002n−f00001][100−r+l2010−t+b2001−n+f20001]M_{ortho}=\\begin{bmatrix}\\frac{2}{r-l}&amp;0&amp;0&amp;0\\\\ 0&amp;\\frac{2}{t-b}&amp;0&amp;0\\\\ 0&amp;0&amp;\\frac{2}{n-f}&amp;0\\\\ 0&amp;0&amp;0&amp;1\\end{bmatrix}\\begin{bmatrix}1&amp;0&amp;0&amp;-\\frac{r+l}{2}\\\\ 0&amp;1&amp;0&amp;-\\frac{t+b}{2}\\\\ 0&amp;0&amp;1&amp;-\\frac{n+f}{2}\\\\0&amp;0&amp;0&amp;1\\\\ \\end{bmatrix} Mortho​=⎣⎢⎢⎡​r−l2​000​0t−b2​00​00n−f2​0​0001​⎦⎥⎥⎤​⎣⎢⎢⎡​1000​0100​0010​−2r+l​−2t+b​−2n+f​1​⎦⎥⎥⎤​ 透视投影 原来平行的线在投影中不再平行，满足近大远小的现象 步骤 远平面等比例收缩 z不变 平面的中心点不变 图中显然显然有个相似三角形，最后y′=nzyy^{&#x27;} = \\frac{n}{z}yy′=zn​y，同理x′=nzxx^{&#x27;} = \\frac{n}{z}xx′=zn​x (xyz1)⇒(nx/zny/zunknown1)==mult. by z(nxnystill unknownz)\\begin{pmatrix}x\\\\y\\\\z\\\\1\\end{pmatrix}\\Rightarrow \\begin{pmatrix}nx/z\\\\ny/z\\\\ \\text{unknown}\\\\ 1 \\end{pmatrix} \\overset{\\text{mult. by z}}{==} \\begin{pmatrix} nx\\\\ ny\\\\ \\text{still unknown}\\\\ z \\end{pmatrix} ⎝⎜⎜⎛​xyz1​⎠⎟⎟⎞​⇒⎝⎜⎜⎛​nx/zny/zunknown1​⎠⎟⎟⎞​==mult. by z⎝⎜⎜⎛​nxnystill unknownz​⎠⎟⎟⎞​ 最后的z我们不在意，因为最后我们只想要远平面被挤压后在近平面的位置 由此我们的到 Mpersp→ortho(4×4)(xyz1)=(nxnyunknownz)M^{(4\\times4)}_{persp \\to ortho}\\begin{pmatrix}x\\\\ y\\\\ z\\\\ 1\\end{pmatrix}=\\begin{pmatrix}nx\\\\ ny\\\\ \\text{unknown}\\\\ z\\end{pmatrix} Mpersp→ortho(4×4)​⎝⎜⎜⎛​xyz1​⎠⎟⎟⎞​=⎝⎜⎜⎛​nxnyunknownz​⎠⎟⎟⎞​ 而变换矩阵中的某些元素可以确认 Mpersp→ortho=(n0000n00????0010)M_{persp\\to ortho}=\\begin{pmatrix}n&amp;0&amp;0&amp;0\\\\ 0&amp;n&amp;0&amp;0\\\\?&amp;?&amp;?&amp;?\\\\ 0&amp;0&amp;1&amp;0\\end{pmatrix} Mpersp→ortho​=⎝⎜⎜⎛​n0?0​0n?0​00?1​00?0​⎠⎟⎟⎞​ 很好理解，结果矩阵的第一行nx是由x乘上M的第一行的每一列再相加的到的，所以除了第一列对应x的那一项其他都是0 那么剩下的该如何确定，我们还有两个特殊点没有代入 在近平面的点没有变化 其他平面点的z没有变化 代入z = n得： Mpersp→ortho(4×4)(xyz1)=(nxnyunknownz)=代入z=n(xyn1)⇒(xyn1)==(nxnyn2n)M^{(4\\times4)}_{persp\\to ortho}\\begin{pmatrix}x\\\\ y\\\\ z\\\\ 1\\end{pmatrix}=\\begin{pmatrix}nx\\\\ ny\\\\ \\text{unknown}\\\\ z\\end{pmatrix} \\overset{\\text{代入z=n}}{=} \\begin{pmatrix}x\\\\ y\\\\ n\\\\ 1\\\\ \\end{pmatrix}\\Rightarrow\\begin{pmatrix}{x}\\\\ y\\\\ n\\\\ 1\\end{pmatrix}==\\begin{pmatrix}{n x}\\\\ n y\\\\ n^2\\\\ n\\end{pmatrix} Mpersp→ortho(4×4)​⎝⎜⎜⎛​xyz1​⎠⎟⎟⎞​=⎝⎜⎜⎛​nxnyunknownz​⎠⎟⎟⎞​=代入z=n⎝⎜⎜⎛​xyn1​⎠⎟⎟⎞​⇒⎝⎜⎜⎛​xyn1​⎠⎟⎟⎞​==⎝⎜⎜⎛​nxnyn2n​⎠⎟⎟⎞​ (00AB)(xyn1)=n2\\begin{pmatrix}0&amp;0&amp;A&amp;B\\end{pmatrix}\\begin{pmatrix}x\\\\ y\\\\ n\\\\ 1\\end{pmatrix}=n^2 (0​0​A​B​)⎝⎜⎜⎛​xyn1​⎠⎟⎟⎞​=n2 同理代入远平面的中心点 (00f1)⇒(00f1)==(00f2f)\\begin{pmatrix}0\\\\0\\\\f\\\\1\\end{pmatrix}\\Rightarrow\\begin{pmatrix}0\\\\0\\\\f\\\\1\\end{pmatrix}==\\begin{pmatrix}0\\\\0\\\\f^2\\\\f\\end{pmatrix} ⎝⎜⎜⎛​00f1​⎠⎟⎟⎞​⇒⎝⎜⎜⎛​00f1​⎠⎟⎟⎞​==⎝⎜⎜⎛​00f2f​⎠⎟⎟⎞​ 得到 An+B=n2Af+B=f2\\begin{gathered} An+B=n^2 \\\\ Af+B=f^2 \\end{gathered} An+B=n2Af+B=f2​ 解得 A=n+fB=−nf\\begin{gathered} A=n+f \\\\ B=-nf \\end{gathered} A=n+fB=−nf​ 求正交投影 ","link":"https://pigstar02.github.io/post/GAMES101-4.变换（模型、视图、投影）/"},{"title":"GAMES101-3.变换（二维与三维）","content":"变换 缩放变换 不仅是缩放也可以是放大，只需要把坐标等比例放大或缩小，即 sx=sys_x = s_ysx​=sy​ [x′y′]=[sx00sy][xy]\\left[\\begin{array}{l}{{x^{\\prime}}}\\\\ {{y^{\\prime}}}\\end{array}\\right]=\\left[\\begin{array}{l l}{{s_{x}}}&amp;{{0}}\\\\ {{0}}&amp;{{s_{y}}}\\end{array}\\right]\\left[\\begin{array}{l}{{x}}\\\\ {{y}}\\end{array}\\right] [x′y′​]=[sx​0​0sy​​][xy​] 当sx≠sys_x \\neq s_ysx​​=sy​时，就是一个压缩、拉长的效果 反射变换 类似于一个镜面，选定一条轴，做轴对称图形 [x′y′]=[−100−1][xy]\\left[\\begin{array}{l}{{x^{\\prime}}}\\\\ {{y^{\\prime}}}\\end{array}\\right]= \\left[\\begin{array}{l l}{{-1}}&amp;{{0}}\\\\ {{0}}&amp;{{-1}}\\end{array}\\right] \\left[\\begin{array}{l}{{x}}\\\\ {{y}}\\end{array}\\right] [x′y′​]=[−10​0−1​][xy​] 剪切变换 每个点对应的垂直坐标没变，水平坐标从一条直线偏移成一条斜线，相当于乘上了一个斜率系数 [x′y′]=[1a01][xy]\\left[\\begin{array}{l}{{x^{\\prime}}}\\\\ {{y^{\\prime}}}\\end{array}\\right]= \\left[\\begin{array}{l l}{{1}}&amp;{{a}}\\\\ {{0}}&amp;{{1}}\\end{array}\\right] \\left[\\begin{array}{l}{{x}}\\\\ {{y}}\\end{array}\\right] [x′y′​]=[10​a1​][xy​] 旋转变换 默认以原点为中心，没指定方向默认逆时针 通过待定系数，代入特殊点可得 [x′y′]=[cosθ−sinθsinθcosθ][xy]\\left[\\begin{array}{l}{{x^{\\prime}}}\\\\ {{y^{\\prime}}}\\end{array}\\right]= \\left[\\begin{array}{l l}{{cos\\theta}}&amp;{{-sin\\theta}}\\\\ {{sin\\theta}}&amp;{{cos\\theta}}\\end{array}\\right] \\left[\\begin{array}{l}{{x}}\\\\ {{y}}\\end{array}\\right] [x′y′​]=[cosθsinθ​−sinθcosθ​][xy​] 以上变换都属于线性变换，都可以表达为乘上一个2×2的矩阵 平移变换 [x′y′]=[1001][xy]+[txty]\\left[\\begin{array}{l}{{x^{\\prime}}}\\\\ {{y^{\\prime}}}\\end{array}\\right]= \\left[\\begin{array}{l l}{{1}}&amp;{{0}}\\\\ {{0}}&amp;{{1}}\\end{array}\\right] \\left[\\begin{array}{l}{{x}}\\\\ {{y}}\\end{array}\\right] + \\left[\\begin{array}{l}{t_{x}}\\\\ {t_{y}}\\end{array}\\right] [x′y′​]=[10​01​][xy​]+[tx​ty​​] 这显然不符合线性变换的定义，它额外加上了一个常量矩阵 齐次坐标 对于点增加一个维度标记为1，向量增加一个维度标记为0（想一下，向量是两个点相减，第三维1-1=0） (x′y′w′)=(10tx01ty001)⋅(xy1)=(x+txy+ty1)\\left(\\begin{array}{c} x^{\\prime} \\\\ y^{\\prime} \\\\ w^{\\prime} \\end{array}\\right)=\\left(\\begin{array}{ccc} 1 &amp; 0 &amp; t_{x} \\\\ 0 &amp; 1 &amp; t_{y} \\\\ 0 &amp; 0 &amp; 1 \\end{array}\\right) \\cdot\\left(\\begin{array}{c} x \\\\ y \\\\ 1 \\end{array}\\right)=\\left(\\begin{array}{c} x+t_{x} \\\\ y+t_{y} \\\\ 1 \\end{array}\\right) ⎝⎛​x′y′w′​⎠⎞​=⎝⎛​100​010​tx​ty​1​⎠⎞​⋅⎝⎛​xy1​⎠⎞​=⎝⎛​x+tx​y+ty​1​⎠⎞​ 为什么区分点和向量：向量有平移不变性，那么向量乘上平移的变换矩阵，第三维的0会把平移的影响化掉 原因：由于上面的平移变换无法和前面的变换用一个矩阵统一起来，于是引入了齐次坐标 缺点：多引入了一个维度，空间占用更大 点、向量运算 向量 + 向量 = 向量 点 - 点 = 向量 点 + 向量 = 点 上述运算对于第三维的结果都是和原来的定义匹配的 点 + 点本来是没有定义，认为规定等于原来两个点的中点 原因：相加第三维变成了2，所有元素同除以w将它变为1 齐次坐标表示仿射变换 一般形式 (x′y′1)=(abtxcdty001)⋅(xy1)\\left(\\begin{array}{l} x^{\\prime} \\\\ y^{\\prime} \\\\ 1 \\end{array}\\right)=\\left(\\begin{array}{llc} a &amp; b &amp; t_{x} \\\\ c &amp; d &amp; t_{y} \\\\ 0 &amp; 0 &amp; 1 \\end{array}\\right) \\cdot\\left(\\begin{array}{l} x \\\\ y \\\\ 1 \\end{array}\\right) ⎝⎛​x′y′1​⎠⎞​=⎝⎛​ac0​bd0​tx​ty​1​⎠⎞​⋅⎝⎛​xy1​⎠⎞​ 伸缩变换 S(sx,sy)=(sx000sy0001)\\mathbf{S}(s_{x},s_{y})={\\left(\\begin{array}{l l l}{s_{x}}&amp;{0}&amp;{0}\\\\ {0}&amp;{s_{y}}&amp;{0}\\\\ {0}&amp;{0}&amp;{1}\\end{array}\\right)} S(sx​,sy​)=⎝⎛​sx​00​0sy​0​001​⎠⎞​ 旋转变换 R(α)=(cos⁡α−sin⁡α0sin⁡αcos⁡α0001){\\bf R}(\\alpha)=\\left(\\begin{array}{l l l}{{\\cos{\\alpha}}}&amp;{{-\\sin{\\alpha}}}&amp;{{0}}\\\\ {{\\sin{\\alpha}}}&amp;{{\\cos{\\alpha}}}&amp;{{0}}\\\\ {{0}}&amp;{{0}}&amp;{{1}}\\end{array}\\right) R(α)=⎝⎛​cosαsinα0​−sinαcosα0​001​⎠⎞​ 平移变换 T(tx,ty)=(10tx01ty001)\\mathrm{T}(t_{x},t_{y})= \\left(\\begin{array}{llc} 1 &amp; 0 &amp; t_{x} \\\\ 0 &amp; 1 &amp; t_{y} \\\\ 0 &amp; 0 &amp; 1 \\end{array}\\right) T(tx​,ty​)=⎝⎛​100​010​tx​ty​1​⎠⎞​ 逆变换 逆变换就是把图形还原到上一步的操作，只需要乘上上一次操作的逆矩阵 复杂变换 要想实现复杂的变换，可以分成多个基本变换的组合 但是多个基本变换之间的顺序不同，最后的效果也不同（这个很好理解，每次变换都是乘上一个矩阵，而矩阵乘法是不满足交换律的） 例如先旋转再平移 T(1,0)⋅R45[xy1]=[101010001][cos⁡45∘−sin⁡45∘0sin⁡45∘cos⁡45∘0001][xy1]T_{(1,0)}\\cdot R_{45}\\begin{bmatrix} x \\\\ y \\\\ 1 \\\\ \\end{bmatrix}= \\begin{bmatrix} 1 &amp; 0 &amp; 1 \\\\ 0 &amp; 1 &amp; 0 \\\\ 0 &amp; 0 &amp; 1 \\\\ \\end{bmatrix} \\begin{bmatrix} \\cos45^\\circ &amp; -\\sin45^\\circ &amp; 0 \\\\ \\sin45^\\circ &amp; \\cos45^\\circ &amp; 0 \\\\ 0 &amp; 0 &amp; 1 \\\\ \\end{bmatrix} \\begin{bmatrix} x \\\\ y \\\\ 1 \\end{bmatrix} T(1,0)​⋅R45​⎣⎡​xy1​⎦⎤​=⎣⎡​100​010​101​⎦⎤​⎣⎡​cos45∘sin45∘0​−sin45∘cos45∘0​001​⎦⎤​⎣⎡​xy1​⎦⎤​ 运算顺序 An(⋅⋅⋅A2(A1(x)))=An⋅⋅⋅A2⋅A1⋅(xy1)A_{n}(\\cdot\\cdot\\cdot A_{2}(A_{1}(x)))=\\mathrm{A_{n}\\cdot\\cdot\\cdot A_{2}\\cdot A_{1}}\\cdot\\left(\\begin{array}{c}{{x}}\\\\ {{y}}\\\\ {{1}}\\end{array}\\right) An​(⋅⋅⋅A2​(A1​(x)))=An​⋅⋅⋅A2​⋅A1​⋅⎝⎛​xy1​⎠⎞​ 由于矩阵满足结合律，我们可以对An⋅⋅⋅A2⋅A1\\mathrm{A_{n}\\cdot\\cdot\\cdot A_{2}\\cdot A_{1}}An​⋅⋅⋅A2​⋅A1​先进行运算，最后再乘上原始矩阵 所以任何一个很复杂的变化可以表示为一个三维矩阵 以任意一点旋转 先移动到原点 旋转 移动回原来的位置 切记先进行的变换矩阵在最右边 三维空间中的变换 表示形式 点 = (x,y,z,1)T(x, y, z, 1)^{T}(x,y,z,1)T 向量 = (x,y,z,0)T(x, y, z, 0)^{T}(x,y,z,0)T 若(x,y,z,w)(w≠0)(x,y,z,w)(w \\neq 0)(x,y,z,w)(w​=0)表示点(xw,yw,zw,1)(\\frac{x}{w},\\frac{y}{w},\\frac{z}{w},1)(wx​,wy​,wz​,1) 变换矩阵 一般形式 (x′y′z′1)=(abctxdeftyghitz0001)⋅(x′y′z′1)\\left(\\begin{array}{c} x&#x27; \\\\ y&#x27; \\\\ z&#x27; \\\\ 1 \\end{array}\\right) = \\left(\\begin{array}{llc} a &amp; b &amp; c &amp; t_x \\\\ d &amp; e &amp; f &amp; t_y \\\\ g &amp; h &amp; i &amp; t_z \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{array}\\right) \\cdot \\left(\\begin{array}{llc} x&#x27; \\\\ y&#x27; \\\\ z&#x27; \\\\ 1 \\end{array}\\right) ⎝⎜⎜⎛​x′y′z′1​⎠⎟⎟⎞​=⎝⎜⎜⎛​adg0​beh0​cfi0​tx​ty​tz​1​⎠⎟⎟⎞​⋅⎝⎜⎜⎛​x′y′z′1​⎠⎟⎟⎞​ 缩放变换 S(sx,sy,sz)=(sx0000sy0000sz00001)\\mathbf{S}(s_x,s_y,s_z)=\\begin{pmatrix}s_x&amp;0&amp;0&amp;0\\\\ 0&amp;s_y&amp;0&amp;0\\\\ 0&amp;0&amp;s_z&amp;0\\\\ 0&amp;0&amp;0&amp;1\\end{pmatrix} S(sx​,sy​,sz​)=⎝⎜⎜⎛​sx​000​0sy​00​00sz​0​0001​⎠⎟⎟⎞​ 平移变换 T(tx,ty,tz)=(100tx010ty001tz0001)\\mathbf{T}(t_x,t_y,t_z)=\\begin{pmatrix}1&amp;0&amp;0&amp;t_x\\\\ 0&amp;1&amp;0&amp;t_y\\\\ 0&amp;0&amp;1&amp;t_z\\\\ 0&amp;0&amp;0&amp;1\\end{pmatrix}\\quad T(tx​,ty​,tz​)=⎝⎜⎜⎛​1000​0100​0010​tx​ty​tz​1​⎠⎟⎟⎞​ 旋转变换 绕轴旋转 Rx(α)=(10000cos⁡α−sin⁡α00sin⁡αcos⁡α00001)\\mathbf{R}_{x}(\\alpha)={\\left(\\begin{array}{l l l l}{1}&amp;{0}&amp;{0}&amp;{0}\\\\ {0}&amp;{\\cos\\alpha}&amp;{-\\sin\\alpha}&amp;{0}\\\\ {0}&amp;{\\sin\\alpha}&amp;{\\cos\\alpha}&amp;{0}\\\\ {0}&amp;{0}&amp;{0}&amp;{1}\\end{array}\\right)} Rx​(α)=⎝⎜⎜⎛​1000​0cosαsinα0​0−sinαcosα0​0001​⎠⎟⎟⎞​ Ry(α)=(cos⁡α0sin⁡α00100−sin⁡α0cos⁡α00001)\\mathbf{R}_{y}(\\alpha)=\\left(\\begin{array}{c c c c}{{\\cos\\alpha}}&amp;{{0}}&amp;{{\\sin\\alpha}}&amp;{{0}}\\\\ {{0}}&amp;{{1}}&amp;{{0}}&amp;{{0}}\\\\ {{-\\sin\\alpha}}&amp;{{0}}&amp;{{\\cos\\alpha}}&amp;{{0}}\\\\ {{0}}&amp;{{0}}&amp;{{0}}&amp;{{1}}\\end{array}\\right) Ry​(α)=⎝⎜⎜⎛​cosα0−sinα0​0100​sinα0cosα0​0001​⎠⎟⎟⎞​ Rz(α)=(cos⁡α−sin⁡α00sin⁡αcos⁡α0000100001)\\mathbf{R}_{z}(\\alpha)={\\left(\\begin{array}{l l l l}{\\cos\\alpha}&amp;{-\\sin\\alpha}&amp;{0}&amp;{0}\\\\ {\\sin\\alpha}&amp;{\\cos\\alpha}&amp;{0}&amp;{0}\\\\ {0}&amp;{0}&amp;{1}&amp;{0}\\\\ {0}&amp;{0}&amp;{0}&amp;{1}\\end{array}\\right)} Rz​(α)=⎝⎜⎜⎛​cosαsinα00​−sinαcosα00​0010​0001​⎠⎟⎟⎞​ 任意旋转 任意旋转都可以表示为3个绕轴旋转的组合 罗德里格斯旋转公式是针对原点的旋转 只需要平移到原点旋转完再平移回去 ","link":"https://pigstar02.github.io/post/GAMES101-3.变换（二维与三维）/"},{"title":"Makefile入门","content":" 一、语法 tag(生成的目标文件)：(依赖文件) (执行命令) .PHONY:(目标文件)#定义伪目标 二、执行步骤 所有Makefile都是为了执行第一条命令 执行第一条命令，查找相关依赖 若相关先关依赖不存在或存在未更新的情况，则执行生成相关依赖的命令（如果有的话） 重复1,2两条一直递归下去 更新规则 比较生成目标文件和依赖文件的时间，若依赖文件最近更改时间在生成文件之后则更新 注意:依赖文件为空则它的最近更改时间是最前的，即永远不会更新。 三、make clean clean: rm -f *.o 一般clean的使用如上所示，清除一些已生成的代码。 但是除了第一次本地会已存在生成的clean文件，通过比较修改时间，命令将不会执行，提示已是最新。 解决方法:通过定义伪目标可不生成目标文件 .PHONY:clean clean: rm -f *o 四、变量 1.自定义变量 变量名 = 变量值 2.预定义变量 3.获取变量的值 $(变量名称) 4.例子 原来的代码 app: main.c a.c b.c gcc -c main.c a.c b.c 使用变量后 app: main.c a.c b.c $(CXX) -c $^ -o &amp;@ 五、模式匹配 1.通配符 %.o:%.c 两个%匹配的是相同字符 $? 上一条命令的结果 2.例子 add.o:add.c gcc -c add.c sub.o:sub.c gcc -c sub.c div.o:div.c gcc -c div.c ... 使用通配符可以一条命令执行匹配模式规则的所有命令 %.o:%.c gcc -c %.c 六、函数 wildcard 功能：获取制定目录下指定类型的文件列表 参数：指定的目录，多个目录用空格隔开 示例： $(wildcard *.c ./sub/*.c) 返回值： a.c b.c c.c d.c patsubst 查找text是否符合pattern，是的话用replacement替换，返回替换的结果 $(patsubst %.c, %.o, a.c b.c) 返回：a.o b.o ","link":"https://pigstar02.github.io/post/Makefile/"},{"title":"webserver常用指令","content":"webserver函数 socket 定义： int socket(int domain, int type, int protocol); 参数domain指定套接字的域，通常使用AF_INET表示Internet域（即IPv4），或者使用AF_INET6表示IPv6。参数type指定套接字的类型，常用的有SOCK_STREAM表示流套接字（TCP协议），SOCK_DGRAM表示数据报套接字（UDP协议）。参数protocol指定套接字所使用的协议，常用的有IPPROTO_TCP表示TCP协议，IPPROTO_UDP表示UDP协议。但是，如果将参数设置为0，表示让操作系统自动根据域和类型选择协议。 socket(AF_INET, SOCK_STREAM, 0); 创建一个socket（套接字）并返回一个文件标识符，创建失败返回-1 bzero 定义： void bzero(void *s, size_t n); 参数s是要清零的内存块的起始地址，参数n是要清零的字节数。 bzero(&amp;serv_addr, sizeof(serv_addr)); bzero函数将从s开始的n个字节都设置为0。 sockaddr_in 表示服务器地址的结构体 serv_addr.sin_family = AF_INET;//sin_family指定了地址族，这里将其设置为AF_INET表示IPv4。 serv_addr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;);//sin_addr指定了IP地址，inet_addr函数将字符串格式的IPv4地址转换成网络字节序的32位二进制数，赋值给s_addr字段 serv_addr.sin_port = htons(8888);//sin_port指定了端口号，htons函数将主机字节序的16位整数转换为网络字节序的16位整数，赋值给sin_port字段 bind int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen) //sockfd是要绑定的套接字描述符，addr是要绑定的本地地址结构体的指针，addrlen是addr指向的结构体的长度。 bind()函数通常用于将一个本地的地址和套接字进行绑定，bind()函数返回值为0表示绑定成功，否则会返回-1，此时可以通过perror()函数输出具体错误信息。 listen int listen(int sockfd, int backlog); //sockfd是要监听的套接字描述符，backlog是请求队列的最大长度，表示在连接还未被accept()函数处理前，连接请求可以放在队列中等待被处理的最大数量。 listen()函数通常用于将一个套接字设置为被动监听状态，以等待客户端的连接请求。当有连接请求到达时，accept()函数会从连接请求队列中取出一个连接请求进行处理。如果请求队列已满，新的连接请求将被拒绝，客户端将收到一个ECONNREFUSED错误 ","link":"https://pigstar02.github.io/post/webserver常用指令/"}]}